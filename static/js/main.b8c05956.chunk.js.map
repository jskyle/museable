{"version":3,"sources":["stores/artistInfo/ArtistInfoReducers.js","views/components/loading-indicator/LoadingIndicator.js","views/App.js","serviceWorker.js","index.js","stores/rootStore.js","stores/rootReducer.js","stores/artistInfo/ArtistInfoActions.js"],"names":["initialState","artist","name","stats","listeners","playcount","similar","bio","summary","blank","topTracks","toptracks","track","url","topAlbums","topalbums","album","artistInfoReducers","state","action","type","ArtistInfoActions","payload","LoadingIndicator","props","isActive","className","children","cssClasses","classNames","styles","wrapper","loaderContainer","Loader","conten","active","inverted","size","HomePage","lazy","Artist","routes","Boolean","window","location","hostname","match","Component","el","history","createBrowserHistory","basename","store","middleware","thunk","routerMiddleware","filter","createStore","reducerMap","router","connectRouter","combineReducers","rootReducer","composeWithDevTools","applyMiddleware","rootStore","root","document","getElementById","fallback","exact","path","component","ReactDOM","render","dispatch","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","SEARCH_ARTIST_INFO","SEARCH_TOP_TRACKS","SEARCH_TOP_ALBUMS","baseURL","searchArtistInfo","selectedArtist","fetch","res","json","data","searchTopTracks","searchTopAlbums"],"mappings":"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","file":"static/js/main.b8c05956.chunk.js","sourcesContent":["import * as ArtistInfoActions from './ArtistInfoActions'\n\n\nconst initialState = {\n  artist: {\n      name: '',\n      stats: {\n        listeners: '',\n        playcount: ''\n      },\n      similar: {\n        artist:[\n            {\n              name: '',\n            }\n        ]\n      },\n      bio: {\n        summary: '',\n      }\n\n  },\n  blank: null,\n  topTracks: {\n    toptracks: {\n      track: [\n          {\n            name: '',\n            url: '',\n            playcount: '',\n            listeners: '',\n          }\n      ]\n    }\n  },\n  topAlbums: {\n    topalbums: {\n      album: [\n          {\n            name: '',\n            url: '',\n            playcount: '',\n          }\n      ]\n    }\n  },\n\n}\n\n\nexport default function artistInfoReducers (state = initialState, action) {\n  switch(action.type) {\n    case ArtistInfoActions.SEARCH_ARTIST_INFO:\n      return {\n        ...state,\n       artist: action.payload\n      }\n      case ArtistInfoActions.SEARCH_TOP_TRACKS:\n      return {\n        ...state,\n        topTracks: action.payload\n      }\n      case ArtistInfoActions.SEARCH_TOP_ALBUMS:\n      return {\n        ...state,\n        topAlbums: action.payload\n      }\n    default:\n      return state;\n  } \n\n}\n","import styles from './LoadingIndicator.css'\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport { Loader } from 'semantic-ui-react';\n\nexport default function LoadingIndicator(props) {\n  const {isActive = false } = props;\n  const { className, children } = props;\n\n  const cssClasses = classNames(className,  {\n    [styles.wrapper]: isActive\n  });\n\n  return (\n    <div className={cssClasses}>\n      {isActive && (\n        <div className={styles.loaderContainer}>\n          <Loader conten='Loading' active={true} inverted={true} size='huge' />\n        </div>\n      )}\n      {children}\n    </div>\n  )\n}\n","import React, { Suspense, lazy} from 'react';\nimport { ConnectedRouter } from 'connected-react-router'\nimport { Route, Switch } from 'react-router-dom'\nimport './App.css';\nimport LoadingIndicator from './components/loading-indicator/LoadingIndicator'\nconst HomePage = lazy(() => import('./home-page/HomePage'))\nconst Artist = lazy(() => import('./artist-page/AritstPage'))\n\nconst routes = {\n  'Home': '/museable',\n  'Artist': '/museable/artist', \n}\n\n\nexport default function App(props) {\n  return (\n    <ConnectedRouter history={props.history}>\n      <Suspense fallback={<LoadingIndicator isActive={true} />}>\n        <Switch>\n          <Route exact={true} path={routes.Home} component={HomePage}/>\n          <Route exact={true} path={`${routes.Artist}/:artist`} component={Artist}/>\n        </Switch>\n      </Suspense>\n    </ConnectedRouter>\n  );\n}\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux'\nimport { createBrowserHistory } from 'history'\nimport rootStore from './stores/rootStore'\n\nimport App from './views/App'\nimport './index.css';\n\nimport * as serviceWorker from './serviceWorker';\n\nconst initialState = {};\nconst baseRoot = '/'\nconst history = createBrowserHistory({basename: baseRoot})\nconst store = rootStore(initialState, history)\nconst root =   document.getElementById('root')\n\nconst render = (Component, el) => {\n  ReactDOM.render(\n    <Provider store={store}>\n      <Component history={history} dispatch={store.dispatch}/>\n    </Provider>,\n    el\n  );\n}; render(App, root)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n","import { applyMiddleware, createStore } from 'redux';\nimport thunk from 'redux-thunk';\nimport { composeWithDevTools } from 'redux-devtools-extension/logOnlyInProduction';\nimport { routerMiddleware } from 'connected-react-router';\nimport rootReducer from './rootReducer';\n\n\nexport default function rootStore(initialState, history) {\n  const middleware = [null, thunk, routerMiddleware(history)].filter(Boolean);\n\n  const store = createStore(\n    rootReducer(history), \n    initialState, \n    composeWithDevTools(applyMiddleware(...middleware)));\n\n  return store;\n\n}\n","import { combineReducers } from 'redux';\nimport { connectRouter } from 'connected-react-router';\nimport artistInfoReducers from './artistInfo/ArtistInfoReducers'\n\nexport default function rootReducer(history) {\n  const reducerMap = {\n    artist: artistInfoReducers,\n    router: connectRouter(history),\n\n\n  };\n\n  return combineReducers(reducerMap);\n}\n","\n\nexport const SEARCH_ARTIST_INFO = 'SEARCH_ARTIST_INFO'\nexport const SEARCH_TOP_TRACKS = 'SEARCH_TOP_TRACKS'\nexport const SEARCH_TOP_ALBUMS = 'SEARCH_TOP_ALBUMS'\n\n\nconst baseURL = 'https://ws.audioscrobbler.com/2.0/?method=artist' \n\nexport const searchArtistInfo = (selectedArtist) => dispatch => {\n  fetch(`${baseURL}.getInfo&artist=${selectedArtist}&api_key=130ae9b7414a48be61355c187bac5b57&format=json`)\n  .then(res => res.json())\n  .then(data => dispatch ({\n    type: SEARCH_ARTIST_INFO,\n    payload: data.artist\n  }))\n}\n\n\nexport const searchTopTracks = (selectedArtist) => dispatch => {\n\n  fetch(`${baseURL}.gettoptracks&artist=${selectedArtist}&api_key=130ae9b7414a48be61355c187bac5b57&format=json`)\n  .then(res => res.json())\n  .then(data => dispatch ({\n    type: SEARCH_TOP_TRACKS,\n    payload: data\n  }))\n}\nexport const searchTopAlbums = (selectedArtist) => dispatch => {\n\n  fetch(`${baseURL}.gettopalbums&artist=${selectedArtist}&api_key=130ae9b7414a48be61355c187bac5b57&format=json`)\n  .then(res => res.json())\n  .then(data => dispatch ({\n    type: SEARCH_TOP_ALBUMS,\n    payload: data\n  }))\n}\n"],"sourceRoot":""}